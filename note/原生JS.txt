1：script标签属性

	type
	src
	async：异步属性，立即异步下载外部JS，不影响页面其他的操作，JS下载完毕立即执行。
	sync：同步，一个人有序的做多件事。
	defer：异步属性，脚本延迟到文档完全被解析和显示后再执行，只有外部脚本可以使用。
2：javascript的变量

数据分类：第一类是基本类型，第二类是复杂类型。
内存分为两块一块是栈，负责存储简单的数据；另一块是堆，负责存储复杂类型的数据。

变量是在计算机中存储数据的一个标示符。
变量可以在声明的时候赋值，也可以稍后赋值。
可以同一行定义多个变量。


弱类型
JavaScript 是弱类型的脚本语言。

变量命名规则和规范
规则
-由字母、数字、下划线、$组成
-不能是关键字和保留字
-区分大小写
规范
-变量的名称要有意义
-变量的命名遵守驼峰命名法，首字母小写，第二个单词的首字母大写。


3：数据类型
计算机在存储数据时是有类型的。
简单（基本、值）数据类型有，Number、String、Boolean、Undefined、Null
复杂（引用）数据类型
Object、Array、Date等
查看当前变量的数据类型
――typeof name
――typeof(name)






JavaScript的整体感知

1、代码的存放位置。
	如果没有style代码放在title下面。如果有style，那么放在style下面。

2、三句话
alert（“提示框的信息”）；
  效果：在页面上弹出一个提示框，提示信息从引号中来。
  注意：如果页面上出现弹出框时，页面位置不能改变且页面不能关闭，其实这时候浏览器进程暂停。

console.log("这是在console中显示一句话")；
  效果：像浏览器的控制台中输出一句话。
  作用：用来进行代码的调试。

prompt("提供弹出一个输入框，给用户提供输入信息位置。");
3：JavaScript与HTML，css一样，对换行、空格、缩进是不敏感的。
 规范：写代码的时候一定要所有代码都放在代码块中，注意缩进。
JavaScript代码结束可以不加分号，但是必须换行。建议写代码时加上分号和换行，使用格式会更规范。

4：JavaScript注释
//：注释一行代码
/*？？？*/：注释多行代码

5：开发人员工具使用
	右键>审查元素>打开开发人员工具>吐过页面上有错误就会显示一个红叉，说明页面有错误。找到错误直接点击tab选项中的最后一个按钮console，能够看到具体的错误从而排除错误。


一、字符串：string
1、用引号引起来的的文本的串。
2、这个引号既可以是单引号，也可以是双引号。
3、我们日常生活中说的话也可以叫字符串。
4、如果字符串中有引号，可以将字符串中的引号改变为单引号。
5、使用转译符。（右斜杠）
6、常用的转译符，
\‘’：单引号
\""：双引号
\n：换行
\t：缩进
\r：回车

二、数值类型：Number
特点：表达的是一种数据的量。

三、加号的作用
1、两个字符串用加号链接，那么将来加号起到的是链接字符串的作用。
2、两个数值用加号链接，那么将来加号起到的作用是加法运算。
3、如果一个string加一个number，那么字符串输出字符串，number输出number。加号起到链接作用。


四、判断数据类型：


typeof：直接量。

五、console：log(内容)；
作用：也是向页面输出一句话，不是以弹出框的形式输出。
特点：不会让页面“卡死”，直接在控制台中输出。


六、prompt（“”）输入框。
在页面上弹出一个输入框，输入框的提示文本就是引号里的内容。

七：变量
作用：用来存储一些可以变化的数据。
代码：
变量的声明：
	var 变量的名称；
变量的赋值：
变量的名称=要赋值的数据；

变量赋值后的使用（使用方式和直接量一样）
var name；
name=“abc”
alert（name）（不能加引号）。


var name ：声明变量的关键字空格要赋值的数据。


Math.pow(a,b)求a的b次方值。


・・・・・・・・・・・・・・・・・・・・・・・・
函数的三要素： 函数的功能（函数名称），参数，返回值。


函数也是一种数据类型，是对象中function类型的。



返回值（return）是为了返回函数内部的数据。

函数只要调用就会有返回值，

1，如果函数有关键字return及后面有真是的数据，则这个数据就是这个函数的返回值。
2.如果函数里面没有关键字return及后面的数据的话，函数被调用后，会返回undefined。
参数：

参数及之间的关系：

形式参数；定义函数得时候，小括号里的参数叫形参，形式上的参数，起占位作用。
当我们调用函数的时候，传进来的参数叫实参，有实际意义的数据值。

在调用函数的时候，是将实参的数据复制一份，传到函数定义是的形参里。

函数有四种形式

无参无返回值（undefined）

有参无返回值（alert（））

无参有返回值的

有参有返回值的

函数返回值的关键字return


自执行函数：用于只声明和调用一次的函数。

作用域：
1全局作用域：
2.局部作用域：局部作用域可以访问全局作用域。
全局变量：在全局作用域内声明的变量是全局变量。




1.用来返回函数中的真正的数据值
2.用来跳出函数。程序执行到return处，如果有返回值的话，会将返回值返回到函数的外面，然后跳出当前函数，return后面的代码都不会在执行了。
如果return后面没有真正的数据值得花，则此函数有默认的返回值undefined，程序执行到return后，也会跳出函数。
function 函数名（【参数1，参数2】）{
	函数体（要执行的代码）；
}

函数的嵌套：
如果函数内部嵌套一个函数，程序会先执行嵌套里面的函数，执行完毕后，再执行后面的代码。


函数的重载：（函数名不能重复）
在js中，如果函数名相同的话，后面的函数会覆盖前面的函数，所以定义函数名的时候，函数名一定不要重复。
自执行函数：声明完了，立即进行调用执行。多用于执行一次或者调用一次的函数，jQuery中用的多。

・・・・・・・・・・・・・・・・・・・・・・・・

arguments（伪数组的对象）：每个函数里面都有的，
存储的实参元素，相当于一个实参的备份。是函数里面的一个隐式的对象。
函数功能越单一越好。





**回调函数：将函数作为参数进行传递的函数。回调函数就是一个普通函数。
作用：里面封装了可执行的代码，将此函数传递到其他的地方，进行调用。


内置对象：系统中之前已经定义好的对象。比如静态对象Math，不需要new。


内置对象中的日期对象（date）：实例对象，使用的时候，先创建一个对象的实例，通过对象，方法的形式，再去调用方式。
使用日期对象之前，现将日期对象创建出来。
使用构造函数的方式，现将日期对象创建出来。
var date = +new Date（）；
console。log（date）；日期转换成毫秒状态。




自定义对象：对象就是无序属性的集合。
作用：
1.对象可以帮助我们封装一组数据，可以方便我们对数据的传输或是操作。
2.对象可以帮助我们描述一些事物（程序中的事物，和显示中的事物）。
对象组成：属性（变量）    方法（函数）。
JS中的顶级对象是window  window在调用的时候，是可以省略的。





创建对象的方式：new的方式，对象的字面量的方式。
构造函数创建对象：构造函数的函数名第一个字是大写，是一个名词。
构造函数中new帮我们做了什么事情？
1.创建一个空对象
2.将this指向这个空对象
3.执行构造函数里面的代码，给属性和方法赋值。
4.将this返回。



new 关键字的作用：




对象字面量：
使用对象字面量的方式创建对象，对象可以看成是无序属性的集合，也可以看成是键值对的集合。
例：
var o = { 
      name：“张三”，---键值对
      sayHi：function（）{
	console。log（）
}

}；
对象是通过.的方式来访问，或是通过 
对象[属性值]
例如：o[“name”]；
中括号的方式访问对象的形式更加灵活一些。


对象也可以进行遍历   for-in
for（var key in o）{
	console.log（key + o[key]）;
}
键（key）值（o）对
键的var后可以跟任何东西，in后跟对象的名称。




JSON：就是js的对象表示法，是一种数据格式。




面向对象与基于对象的区别：
js是一种基于对象的语言，不是面向对象的语言。
面向对象的语言：c#，c++，php等。
面向对象的三大特征：封装，继承，多态。
面向对象值得是一种编程思想，是用语言来模拟人类的思考方式。



二维数组：





短路运算
&&  找假。找到假后停止运算，返回第一个假或最后一个真。
||  找真。找到真后停止运算，返回第一个真或最后一个假。


// &&找到假后停止运算 返回第一个假  或者 最后一个真
    	console.log(3&&0&&8);//0
    	console.log(3&&5&&8);//8
    	console.log(0&&3); //0
    	console.log(0&&undefined); //0
    	// ||找到真后停止运算 返回第一个真 或者 最后一个假
    	console.log(3||5);//3
    	console.log(0||3||8); //3
    	console.log(0||undefined); //undefined


 五大浏览器： 谷歌，火狐，safari, 欧鹏，IE
国内的浏览器: 360 ,百度，搜狗，王牌，遨游，QQ浏览器，

1.10JS的特点
应用最广泛的一种客户端的脚本语言
脚本语言：不需要编译，直接运行时边解析边执行的语言
弱类型： 对于变量的类型要求不严格，只有在运行的时候，才会确定数据的类型
动态的语言：可以动态的添加属性和方法，再一个就是数组中的元素可以动态的改变
基于对象：内置大量现成对象，编写少量程序可以完成目标

1.11前端三层的关系
  HTML					结构  从语义的角度，描述页面结构
  CSS 					样式  从审美的角度，美化页面
 Javascript				行为  从交互的角度，提升用户体验


1.16JS与html的执行顺序 
页面是从上往下加载执行的
1.17直接量
直接量： 就是可以直接拿过来使用的数据值
1.18变量
变量就是帮助我们往计算机中存储数据的
S中的变量可以存储任意的数据类型
变量的命名规范：
  可以以字母或是_或是$开头，后面跟字母_或是$，但是绝对不能以数字开头，变量当中不能出现特殊符号，也不能使用系统 中的关键字和保留字。
变量的命名一定要有意义，推荐使用驼峰命名法：比如userName
+的作用：
如果+的两边有一边是字符串的话，那么 +起连接的作用
+如果两边都是数字的话，则是数学中的加法运算
1.20.1简单数据类型  
简单数据类型一般是存储于内存中的栈空间中
number   		所有的数字，不管整浮，正负，都是number
string  所有的字符，或是加了””或是’’的都是字符串类型
boolean   true   false 
undefined    变量未赋值的默认值
null        表示对象的一种空的状态 
1.20.2复杂数据类型
  复杂数据类型是存储于内存中的堆空间
Object   Array   Date   function(){}
1.19.1JS的组成
ECMASciprt					JS的基本语法
DOM							文档对象模型(操作页面元素的API)
BOM						浏览器对象模型

1.19.2JS的特点：
应用非常广泛的客户端的脚本语言
弱类型：对于 变量的数据类型要求不严格，只有在程序运行的时候，才会最终确定变量的数据类型
动态语言：可以动态的添加属性和方法，再一个数据是可以变化的


优先级从高到底
()  优先级最高
一元算术运算符  ++   --   !
二元算数运算符  先 *  /  %   后 +   -
关系运算符  >   >=   <   <=
关系(相等)运算符   ==   !=    ===    !==
逻辑运算符 先&&   后||  
赋值运算符 =

1.24数据类型转换
NaN 是number类型  not a number 不是一个数字或者说是非数字  用来表示数值的一种不正常状态，是一个特殊的值
这个值用来表示一个本来要返回数值的操作数未返回值的情况(这样就不会报错了)
 任何涉及NaN的操作都会返回NaN   NaN与任何值都不相等，包括自己
isNaN()  判断值是否(不是数值),接收值后会尝试将值转换为数值，不能转换为NaN.

其它类型转number类型 
隐式类型转换  +   -    *    /    %
任何涉及到数学运算中的-*/%运算，都会先将其它类型转换成number类型，再进行相应的数学运算。
显式类型转换 Number()   parseInt()   parseFloat()
三个把值转换成数值类型的函数：Number()、 parseInt()、 parseFloat()
Number()可以把任意值转换成数值
例如：
var num1 = Number(true); //true返回1  false返回0
var num2 = Number(undefined); //返回NaN
var num3 = Number("hello");  //返回NaN
var num4 = Number("   "); //如果是空字符串返回0
var num5 = Number(123); //返回123，如果是数字，简单返回
var num6 = Number("123abc");  //返回NaN
var num7 = Number("abc123");  //返回NaN
特点： “123”
a.如果转换的内容可以转成数字，那么就直接返回这个内容对应的数字。
b.如果不可以转换那么返回NaN.
c.如果在内容中出现小数，那么小数会保留。
d.如果内容为空，那么转换成0;

1.24.1第二种显式转换  parseInt()
三个把值转换成数值类型的函数：Number()、 parseInt()、 parseFloat()
parseInt()把字符串转换成整数
var num1 = parseInt("12.3abc");  //返回12，如果第一个字符是数字会解析直到遇到非数字结束
var num2 = parseInt("abc123");  //返回NaN，如果第一个字符不是数字或者符号就返回NaN
var num3 = parseInt("");        //空字符串返回NaN，Number("")返回0
var num5 = parseInt("10");      //返回10
var num4 = parseInt("0xA");     //返回10
a.如果转换的内容可以转成数字，那么就直接返回这个内容对应的数字。
b.如果不可以转换那么返回NaN.
c.如果带有小数，那么会去掉小数，而不是四舍五入。
d.如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止.



1.24.2第三种parseFloat()
parseFloat()和parseInt非常相似，不同之处在与
parseFloat会解析第一个. 遇到第二个.或者非数字结束
parseFloat不支持第二个参数，只能解析10进制数
如果解析的内容里只有整数，解析成整数
小数是包括整数的，小数的范围更大


1.1三元表达式  三目表达式
表达式1？表达式2：表达式3
表达式1一般是一个关系表达式或是逻辑表达式，如果表达式1求解的结果是true的话，则表达式2是整个表达式的值，如果表达式1求解的结果是False的话，则表达式3是整个表达式的值。
表达式，什么叫做表达式？



children 仅仅获得子标签节点。
childnodes 获得空白文本和子元素节点。
previoussibling  获得上一个元素和空白文本节点
previouselementsibiling  获得上一个元素节点。
lastchild 获得最后一个空白文本和子元素节点。
lastelementchild 获得最后一个子元素的节点。


parentNode     父标签节点
childeNodes		标准的DOM属性，获取的是子节点，但是高级浏览器是包括文本节点，而IE8及之前的低版本的浏览器，会忽略空白文件节点
Children	    不是标准的DOM属性，但是获得了所有的浏览器的支持，只会获得标签节点。
nextSibling    会获得下一个相邻的节点，高级浏览器不但会获得标签节点，也会获得文本节点，而IE8及之前的浏览器会忽略空白文本节点，是所有的浏览器都支持的方式。 
nextElementSibling  高级浏览浏览器支持的方式，仅会获得标签节点，但是IE8及之前的低版本的浏览器不支持此属性。
firstChild:  同上   父元素的子节点
firstElementChild: 用法同上









节点操作相关：

克隆节点：?cloneNode(true/false)   复制节点。
参数为false或是没有参数的时候，是浅度克隆，只会克隆标签
当参数为true的时候，是深度克隆;


追加节点：appendchild  是在父元素的子元素最后追加节点。
插入节点： insertbefore 将现有的标签节点，剪切下来后，插入到对应位置。
removechild 删除子节点 移除节点
replacechild ： 替换节点，将要替换的节点剪切替换掉要替换的节点。





getattribute ：可以获取HTML标签中任意属性，
.语法

onclick第二个触发会把第一个覆盖掉，只能触发一次
--------
动态创建元素：就是使用Js实现的HTML标签。


document.write（）：（基本不用）



**innerHTML（）：
获取内容：如果是纯文本的话，直接输出，如果有标签的话，会将标签原样渲染出来。
设置内容：如果是纯文本内容的话，而是渲染显示出来对应的文本内容，如果内容有标签的话，则会将标签渲染到浏览器。
优点：如果涉及嵌套的话，潜逃了多层标签的话，会按照原来浏览器渲染的方式进行页面呈现。
缺点：创建出来的有可能是很多的标签对象，如果要设置的话，需要再次获得对应的标签对象。




**document.createElement（“p”）：创建一个标签对象，先是在内存当中创建的，将创建的标签对象赋值到一个变量中，可以追加到想要放的位置。
优点：创建出对应的标签对象之后，直接设置样式或是操作的话，非常方便。
缺点：仅仅只能创建标签对象，如果涉及到多个标签的话，比较麻烦。





树叶过河--全靠一股子浪劲



键盘按下的事件：
onkeydown  键盘按下就会触发的事件，只能获得之前的数据值。
onkeyup   键盘按下并抬起的时候，就会触发的事件，可以将文本框里面的值输出出来。
字符串的索引：
indexOf（）：字符串可以看成是字符的数组。
可以查看字符串中的索引位置。
可以查看单个数据，也可以查一组数据。
不存在的字符就是-1.
indexOf（“a”，3）；从索引为3的位置开始往后找a这个数据。






BOM  浏览器对象模型。（brower objects model）
window ：浏览器的顶级对象。在全局作用域内定义的变量都可以看成是window的属性，而函数都可以看成是window对象的方法。
window.onload  当页面中所有的资源都加载完毕之后，才会来执行里面的代码。



两个定时器：
setInterval（）：间隔时间后才会执行函数，是死循环去执行的。
clearInterval：清除定时器。
setInterval（function（），毫秒）
定时器使用完毕后必须清除，即使运动停止了，定时器实际上还在空转。


setTimeout（）：延迟时间后才会执行，只能执行一次。
cleartimeout：清除定时器。
settimeout（function(）{},毫秒);
transform：rotate（30deg）；
旋转（多少度）；


js是单线程的。
三种异步任务：
定时器：
当前代码执行时间短于定时器的等待时间，正常执行。
当前的代码执行时间较长，长过了定时器需要等待的时间，这时时间到了也不能执行。
ajax：
事件：

数据类型：
基本类型成为值类型。
复杂类型又叫引用类型。

简单运动：
标签offsetleft：表示当前元素到定位的父盒子之间的距离，边框到边框。只读属性。
标签的新位置 = 标签的旧位置 + 步长。


预解析：
每个作用域内部都存在预解析，预解析分为两步，两步不分先后：
1.找到当前作用域内部的变量声明，将变量的声明语句提升到当前作用域顶端，赋值语句保留在原地。
2.找函数声明语句，会将函数体进行整体提升（调用语句不提升）这是函数提升。
注意：函数表达式遵循的是变量提升的规则。


局部作用域内部的预解析：
每个作用域的提升都是提升到当前作用域的顶端。
变量使用的查找方式，当前作用域没使用一个变量a，当前作用域内没有生命，向父级作用域查找，如果没有，一直向上查找，一直找到全局作用域，如果还没有，则这个a就是全局变量。
如果半路找到了a，这时修改遇到的这个a的值。

字符串的属性：
基本包装类型：
length可以得到字符创的长度
字符串是基本类型，只有对象具有属性方法，向字符串这种使用方式比较特殊，在使用字符串的属性或方法时，由于字符串是一个基本类型，所以不具有属性和方法。但是js为了方便我们使用字符串这种基本类型值，会在我们使用字符串的属性或方法时给我们创建一个对象，这个对象我们成为基本包装类型对象。

字符串的方法：
大小写转换
var str = "ABCdef";
 var str1 = str.toUpperCase();转换为大写
 console.log(str1);
 var str2 = str.toLocaleLowerCase();转换为小写
 console.log(str2);
操作方法：
字符串连接：str.concat（strnew）;几乎不用，字符串使用+操作比较方便。

获取字符串的内容：

slice（start，end）获取的时候只含有start，不含有end。str.slice(索引值，索引结束值)
substr（start，length）start表示获取的起始位置的索引值，length表示获取字符串的个数。
substring（start，end）用法和slice基本一样，一般使用slice。
替换方法

replace（要替换的字符串，替换成什么字符串);注意：替换的时候只能替换一次，第一个。



位置方法：
indexOf(要查找的字符串，检索的起始位置的索引值)，第二个参数可选。从前面开始找，如果找不到返回值是-1；
lastIndexOf（）一般不用

转换方法：
split（）分割字符串，或者字符串转换成数组。
str。split（“”）
数组中的join（）合并数组。

去除空格：trim（）去除字符串两端的空格，字符串中间的空格不能去掉。


indexof 查找元素在数组中的索引位置
1.如果只有一个参数的时候，就是查找此元素在数组中的索引位置，只找第一个。
2.如果有这个元素，则返回这个元素的索引位置。如果找不到，则返回-1.
3.如果有两个参数，则表示，从第二个参数的索引位置开始往后找。
lastindexof 从数组后面开始查找。
valueof：打印数组的原始样式。

数组的连接：join（）连接  将数组中的元素连接成字符进行输出。如果没有参数的话，默认是以逗号进行连接后并输出。

合并数组：arr.concat（要连接的数组）将两个数组进行合并。


为数组添加元素：arr.push（）；追加元素的返回值是数组的新长度。从数组中最后面添加数据。
pop（）；删除数组中的最后一项，返回值就是删除的那个元素。
unshift（）：从数组中最前面添加数据，返回数组的新长度。
shift（）；删除数组的第一项，返回删除的这个元素。
数组的常用方法
1.indexof（）：从前面开始找某元素在数组中的索引位置。
2.lastIndexof（）：从数组的最后开始查找某元素在数组中的索引位置。
3.arr.join（）：将数组中的元素以某种分隔符连接成字符串进行输出。
4.arr.concat（arr1）：合并数组。
5.push 将元素添加到数组最后，返回值是数组的新长度。
6.arr.pop（）：删除数组最后一个元素，返回值是删除的元素。
7.arr.UNshift（）：从数组最前面添加，返回值是数组的新长度。
8.arr.shift（）：删除第一项，返回的删除的元素。


函数的三要素：函数名，参数，返回值。
arguments.length  表示函数中传入实参的个数。
arguments[0]；表示输出下标为0的实参。

数组和伪数组的区别，伪数组没有数组的方法。

按钮.click();


缓动公式
step = （target - leader）/ 10；
offsetLeft  在取值时会四舍五入。为了不让四舍五入，用向上取整。
/缓动公式的一部分是更改step的值
var step = (400 - leader ) / 10;
//由于offsetLeft在取值的时候会四舍五入，我们的step如果比较小，会造成无法运动的问题
//我们采取取整的方式
step = Math.ceil(step);

offsetleft：边框到边框的距离，不包含边框。
offsetwidth：盒子左边框左侧到盒子有边框右侧的距离，不含margin。
offsetheight：盒子上边框顶部到地边框下面的距离，不含margin。


offsetHeight和style.height的区别
demo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取
style.height是字符串（而且带单位），offsetHeight是数值
demo.style.height可以设置行内样式，offsetHeight是只读属性
一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度
offsetHeight = height+padding+border
包括 自身高度 内边距 边框 不包括 外边距




offsetLeft和style.left的区别
一、style.left只能获取行内样式
二、offsetLeft只读，style.left可读可写
三、offsetLeft是数值，style.left是字符串并且有单位px
四、如果没有加定位，style.left获取的数值可能是无效的
五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准


标签.offsetParent C 表示某个标签外面定位的父盒子（不一定是父节点，也可能是爷爷）



样式属性操作的问题
getComputedstyle：获取计算后的样式（获取各种形式设置的样式，行内，外联，等设置的样式）

getComputedstyle（第一个参数，第二个参数）
第一个参数是要获取的标签，第二个参数传null或false。
获取结果是一个样式的集合（对象）
currentstyle  IE8适用。
不常用的cssText方法  可以一次设置多个样式。
box.style.CSSText = “width：100px；height：100px；”；




scrollHeight和scrollWidth
返回标签内部实际内容的高度/宽度
不计算边框，如果内容不超出盒子，值为盒子的宽高（不带边框）
如果内容超出了盒子，就是从顶部或左部边框内侧一直到内容的最外部分
scrollTop和scrollLeft
被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离
scrollTop：元素内部被卷曲的高度。设置或返回匹配元素相对滚动条顶部的偏移
onscroll 滚动滚动条的时候触发事件。
scrollTo（第一个参数是横向滚动距离，第二个参数是纵向滚动距离）



window.scrollY IE高版本不兼容
window.pageYOffset IE低版本不兼容。

client:
clientHeight 和clientWidth 获取的是元素内部的真实宽度和高度（边框到边框的距离  包含padding）
clientLeft  clientTop 相当于左边框或上边框的值。如果滚动条在左边则也包含滚动条的值。
onresize  获取页面可视区域的宽高定义和用法。
onresize 事件会在窗口或框架被调整大小时发生。
direction： rtl（right to left）；右边的滚动条放到左边。


事件的基本操作：
（1）简单的事件清除，执行完后用onclick = null
（2）简单的事件添加方式，每个事件只能添加一次，相互之间会产生覆盖，用添加事件的新方式
addEventListener 添加事件监听，可以防止多次事件的覆盖问题。
btn.addEventListener（“click”，function（）{}）两个参数，第一个参数为事件类型不加on，第二个为事件处理程序。第三个参数可以控制是冒泡触发还是捕获触发，不传默认为false，表示冒泡。
传true表示捕获。
移除事件：removeEventListener（“click”，）；两个参数，第一个是移除的事件类型，第二个为事件处理程序，由于可能添加过多次事件，需要在移除时指明要移除哪一个事件的处理程序，需要保证移除的参数跟设置是的参数是同一个。

ie6-10支持attachEvent（）第一个参数为事件类型，需要加on，第二个参数，事件处理程序。
在ie8和以下添加事件的时候，需要注意事件的添加的顺序，反向。
移除使用detachEvent（）。


事件冒泡：是事件传播的一个过程，传播方式由最特定元素（触发的那个元素），冒泡到最不特定元素（父级，爷爷辈等）。在传播的过程中，如果某一个父级元素具有了相同类型的事件，就会触发。在传播过程中，不会因为某个父级元素没有相同类型的事件而终止。注意，传播的时候只会是父子之间进行传播，同级之间不能传播。
取出触发事件的元素的方式  target srcElement
事件冒泡：从里向外冒泡。
事件捕获：从外向里捕获。由做不特定元素，触发到最特定元素。
取消事件冒泡和事件捕获：
e.stopPropagation（）；
注意：如果强行添加捕获的执行方式，执行的时候是采用从外向里的触发方式，尽管阻止了传播，也无法执行到需要触发的元素，不要使用捕获。
在IE中只有事件冒泡，事件对象e在ie低版本不支持，window.event作用跟e相同。window.event.window.cancelbubble = true；在ie中阻止事件冒泡。

事件对象（e）：包含了包含了关于当前事件触发时的一些信息。
e.clientX 鼠标针对页面可视区域的横坐标
e.clientY 鼠标针对页面可视区域的纵坐标

鼠标移动事件：
onmousemove 当鼠标在页面上移动是，让图像跟着鼠标动。


鼠标针对页面的坐标：
e.pageX  e.pageY page系列属性在ie低版本不支持，ie也没提供，封装函数
鼠标居中跟随：


onmousedown  鼠标按下事件
onmouseup 鼠标抬起事件

循环的动态创建元素会让页面回流，为了避免多次触发回流，我们可以先使用一个新创建document.creatDocumentFragment进行存储。
document.creatDocumentFragment 相当于一个占位符，这个标签在添加到页面中时，不会将自身也放入，而是放入内部的所有节点。既不会影响页面（添加多余标签），也可以提高性能。
在循环中动态设置innerHtml会出现很大的性能问题，用appendchild快。
不止是不要在循环中使用innerHtml += 因为有性能问题，也不要使用任何的innerHtml +=的形式了 ，除非确定当前标签内已存在的元素不存在事件了。

正则表达式：
作用是验证内容。
先创建一个正则对象
构造函数创建方式：var reg = new regExp（/abc/）；
字面量形式：var reg = /abc/；作用：可以匹配一个字符串中是否含有abc


正则方法 reg.test(str)；返回true或false，只要内容中具有连续的abc就返回true。


在正则中使用中括号表示中括号中的内容表示一位字符，只要有任意一位字符就返回true。

在中括号内部的开头使用shift + 6角符号，表示反向，只要有不是中括号中内容以外的任意一个字符就可以。

在正则最开始的地方写角，表示以后面的设置的内容开头。

在正则的最后使用$，表示必须以正则表达式中的内容结尾。

如果角和$同时使用，表示严格匹配，必须和输入的内容完全相同。

跟用或逻辑“|”使用比较相似。可以同时操作多个字符。与中括号相似。只不过或逻辑可以分辨两个或者多个字符。

范围类var reg = /[a-n]/；表示a-n之间所有的小写字母。
var reg = /[A-N]/；表示a-n之间所有的大写字母。

匹配所有的数字：var reg = /[0-9]/；

匹配所有数字小写字母大写字母：
var reg = /[0-9a-zA-Z]/；
组合类可以自由匹配。
var reg = /[1-5a-mA-M]/；

大括号的用法
var reg = /^a{10}$/；表示a必须出现十次
var reg = /^a{4,}$/；至少出现4次。
var reg =/^a{5,10}$/；出现5到10次包含5次和10次。
除了自定义的次数外，正则中还准备了定义好的次数匹配方式。
* 表示0次到多次
var reg = /^a*$/；
+ 表示一次到多次，至少一次
var reg = /^a+$/；
？ 表示0次或1次
var reg = /^a?$/；

使用到了正则的方法：
replace（str.replace（/a/g,"!"））g表示全局匹配，匹配所有可以匹配到的内容。
匹配模式 i 忽略大小写。
\s 表示不可见字符

trim 去除字符串两端空格。ie9以下不支持。


字符串方法match



jQuery简介：
1.jQuery是一个js库，可以让js代码更加简洁。
2.入口函数可以有很多个。
3.兼容性很好。
4.容错性强。
5.实现运动的代码简单。
6.链式编程。
jQuery入口函数：
第一种写法：$（document）.ready（function（）{
}）；
第二种写法：$（function（）{
}）；

二：js入口函数和jq入口函数的执行顺序：

js入口函数 window.onload = function（）{
}；
js的入口函数：页面完全加载（文件，图片，结构）全部加载完成后执行
jq入口函数的执行时机：页面结构加载完毕后执行
jq的两种入口函数的执行顺序，谁先写谁执行。


三：$是什么
$（）；$本质上是一个函数，实际上是调用函数$。根据传入的参数不同，会产生不同的功能。
$的功能：
1.选择器   找到页面中的指定标签，传入字符串
2.入口函数  传入function（）{}
3.转换dom对象，让基础的dom对象具有新的功能

四：jq对象和dom对象之间的关系：
1.dom对象：通过dom中的属性和方法获取的标签，
dom对象无法使用jq中的属性和方法。
2.jq对象：通过jq方法获取的标签，jq对象无法使用dom中的属性和方法。
3.jQuery对象是dom对象的包装集。jq对象操作，内部会隐式迭代，自动遍历。

五：将dom对象转换为jq对象的方式
1. var box = document.getElementById（“box”）；
$(box).text("今天天气不错"）;
2. 将jq对象转换为dom对象
var $box = $("#box");
$("box").get(0).innertext = "今天天气不错"；get（0）中的0是索引值。
其实是将jq对象中的某一个dom对象取出。
$("div")[1].innerHtml = "今天天气不错"；



标签选择器：$("div")
id选择器：$("#box")
class类选择器：$(".box")
并集选择器：$("div,p,span")
交集选择器：$("span.sp")
子代选择器：必须是子元素中满足条件才可以。
$("div>span").text("记住jq是括号加内容")；
后代选择器：可能是儿子也可能是孙子。
$("ul li").css("backgroundColor","red")
过滤选择器：
（1）：eq 找到所有标签中的某一个
$("div:eq(索引值)").text("我是DIV")；
（2）：odd 索引值为奇数的一部分标签
$("div:odd").text("我是奇数部分")；
（3）：even 索引值为偶数的一部分标签
$("div:even").text("我是偶数部分")；



筛选选择器：
children  子代
链式编程：
$("ul").css().children("li").text("")
每次对一个对象调用一个设置型操作后，都可以继续针对当前对象进行操作。
链式编程的原理，由于设置型操作不需要返回值，jq的方法利用这一特点，return this；

find()   后代
$("ul").find("li").css()


parent() 相当于parentNode  父级


siblings() 同级元素

使用eq方法可以避免拼字符串的问题，同时使用的情景可以灵活掌控。
$("div").eq(index)

mouseenter  移入事件  不会产生冒泡的事件。
mouseleave  移出事件  不会产生冒泡的事件。
show  显示  hide 隐藏
jq中可以通过index（）获取某个元素在同级元素中的索引值。

jq中css操作方法：
同时设置多个样式可以用对象
css({
"width":"100px",
"height":"100px"
})
获取型操作是无法进行隐式迭代的，获取后的结果是第一个元素的属性值。


添加类名： addClass（）；单纯添加新的类名，其他类名还在。
移除类名：removeClass（）；可以移除多个也可以移除单个，多个时中间空格。
切换类名：toggleClass（）；传入一个或多个类名，如果标签具有某个类名，就会去掉，如果没有就会添加。
检测是否具有某个类名：hasClass（）；返回值是true或false。如果检测多个时，顺序不能乱。所以这个方法一般不使用，只是检测一个。

show和hide 运动的方法就是宽，高，透明度同时运动。

下拉（卷帘门）动画 slideDown（）；
可以不传参数，默认是400毫秒，也可以传入时间。
上拉动画 slideUp（）；
默认值也是400毫秒。
切换效果  slideToggle（）；可以一个按钮变换两个效果。


fade动画：渐入渐出
fadeIn（）；渐入
fadeOut（）；渐出
fadeToggle（）；切换
fadeTo（）；渐到，传入两个参数第一个是时间，第二个是透明度参数。一般不使用。原因会影响其他三个运动效果。


自定义动画：
animate（）；可以自定义任意样式的属性。颜色不能运动的。传入三个参数，第一个参数传一个对象，可以改变宽高等，第二个参数传多少秒，第三个参数传运动参数 匀速“linear” 
缓动“swing”



动画队列：如果当前运动没有完毕，又添加了新的动画，这时新的动画需要等待当前动画执行完毕才会开始，

stop（）；两个参数，默认值是（false，false）
第一个参数是布尔值，表示是否清除动画队列。
第二个参数是布尔值，表示是否跳到当前运动的最终效果。



创建元素和添加元素：
1.append（）
2.append可以直接创建标签兵添加到页面中。
3.append添加位置在子元素后面。
prepend（）添加到子元素的前面。
after（）添加到同级元素的后面。
before（）添加到同级元素的前面。

appendTo 和 prependTo 
appendTo 我们可以在操作要添加的子节点时使用，将其放入到某个父元素中
prependTo 放到子元素前面。
html（）删除某个元素内所有子元素，直接传一个空字符串。使用html方法进行清除时，如果有个标签有事件，则不会清除事件。
empty（）用于清除内部的所有元素，包括事件。
remove（） 清除内部及自身，相当于自杀。


空字符串。使用html方法进行清除时，如果有个标签有事件，则不会清除事件。
empty（）用于清除内部的所有元素，包括事件。
remove（） 清除内部及自身，相当于自杀。

――――――――――――――――――――――――――――――――――――――――――
获取属性
prop 方法获取元素行内自带属性。
设置属性值，
1、设置单个属性$("#box").prop("id","box1");
2、设置多个属性传入对象。
3、使用prop获取不到自定义的行内属性值。
4、使用attr方法获取自定义的行内属性。
5、使用attr方法可以设置自定义属性，设置多个用对象。


――――――――――――――――――――――――――――――――――――――――――
总结：一般用prop方法获取和设置自带的行内属性值，用attr设置或获取自定义的行内属性值。
克隆P标签，放入到box中
//clone（）
默认不传参数 参数为false false表示深复制 赋值标签以及内部内容
如果参数传true 不知会复制结构，还会复制事件
text 智能设置或者获取纯文本
html 能解析内部的标签
表单的内容设置和获取 val（）
获取焦点 focus
失去焦点 blur
――――――――――――――――――――――――――――――――――――――――――
css("width")
js中对样式操作提供了新方法

height和width只是值 不含别的

innerWidth 含padding+width

outerWidth 含border + padding + width

outerWidth（true）含border + padding + width + margin

改变的都是Width
――――――――――――――――――――――――――――――――――――――――――
设置offset系列属性
设置的值是含margin的，这个值是box的边框左侧到页面左侧
*必须传入对象*
$("#box").offset({
"left":100,
"top":100
});
如果offset没定位则会设置一个定位，relative相对定位
改变的都是Width
――――――――――――――――――――――――――――――――――――――――――
position().left position().top
*只读属性*
不含margin   不要给操作元素加margin
边框到边框的距离
――――――――――――――――――――――――――――――――――――――――――
**事件添加方式**
on方法
简单事件添加
$().on()
多个事件添加
$().on({
	对象
	属性名：属性值
})
//事件委托：参数1 事件类型 参数2 选择器 参数3 事件处理程序
$().on("click","p,span",function(){
//执行的代码
})
解绑事件 off方法
解绑某个事件
$().off();
解绑委托事件
$().off("click","**");
解绑所有事件
$().off();
――――――――――――――――――――――――――――――――――――――――――
简单事件触发 click（）；
使用trigger方法触发

想触发又不想触发默认效果
使用triggerHandler方法
――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――
nextAll
prevAll
end方法可以让用户继续使用上一次操作的对象
――――――――――――――――――――――――――――――――――――――――――


onmousewheel 鼠标滚轮事件。
fullpage


offsetX：以注册事件的当前元素的左上角为原点确定鼠标坐标。
clientX：客户端（浏览器的页面）的左上角为原点确定鼠标坐标。
layerX：与pageX一样。有兼容问题。
screenX：屏幕（显示器）左上角为原点来确定鼠标坐标。
pageX：页面的左上角。
XY：与page一样。



$冲突

var $1 = $.noConflict();

eval()这个函数可以将js格式的字符串作为代码来执行，在代码中，凡是使用eval函数的地方就与直接执行js代码一样。



call和apply的用法
作用：call，apply  作用是一样的，但是调用参数的形式不同。
apply 可以由调用者决定函数调用中，this的意义。

exec方法的语  
法

正则表达式.exec（字符串）->Array
1，第0个元素，就是匹配到的元素，第i个元素分别表示第i组，解析匹配结果的功能。例如（）优先级分配第123组
2，如果全局（g），那么调用该方法，每次都会向下一个数据进行查找（不停地调用【利用循环直到判断为空跳出循环】）


复习json，敲07玩一玩.html
歌曲全选全不选.html

str.replace（/正则/,""）
    

那些被直接挂在到构造函数上的方法与属性，与具体的实例对象没有直接的关系，因此将其称为静态方法，而写在原型中的方法，必须使用实例对象才可以调用，因此成为实例方法。


attr（非布尔值）和prop（布尔值）的区别


函数也是对象。
构造函数的执行过程：
var p = new person（）；
1、执行代码，遇到赋值运算符，先计算等号邮编的内容
2、首先执行new运算符，创建对象。
3、当对象创建完毕后（因为对象是引用类型），将新创建的对象的引用传递给构造函数。
4、默认构造函数使用this来接收穿过来的新建对象的引用。
5、从上至下的执行构造函数，由于对象具有动态特性。这里相当于是给对象添加属性和方法，因此将其称为初始化对象
6、构造函数执行结束以后，默认返回this，由p接收。






































